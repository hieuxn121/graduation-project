let logger,models,StatusCodes,getErrorMsg,bcrypt,jwt;_fd3‍.x([["default",()=>_fd3‍.o]]);_fd3‍.w("npmlog",[["default",["logger"],function(v){logger=v}]]);_fd3‍.w("../models",[["default",["models"],function(v){models=v}]]);_fd3‍.w("http-status-codes",[["StatusCodes",["StatusCodes"],function(v){StatusCodes=v}]]);_fd3‍.w("../utils/common",[["getErrorMsg",["getErrorMsg"],function(v){getErrorMsg=v}]]);_fd3‍.w("bcryptjs",[["default",["bcrypt"],function(v){bcrypt=v}]]);_fd3‍.w("jsonwebtoken",[["default",["jwt"],function(v){jwt=v}]]);






const {
  sequelize
} = models;

_fd3‍.d({

  // Admin create new lession 
  login: async (req, res) => {
    const { email, password } = req.body;
    let loadUser;
    try {
      const [listUser, _1] = await sequelize.query(
        "select * from users where email = (:email) AND password = (:password)",
        {
          replacements: {
            email,
            password
          },
        },
      );
      if (listUser && listUser.length != 0) {
        loadUser = listUser[0];
        const token = jwt.sign({
          email: loadUser.email,
          userId: loadUser.user_id.toString()
        },
          "somesupersecretkey",
          { expiresIn: '1h' }
        );
        return res.status(StatusCodes.CREATED).send({
          status: StatusCodes.OK,
          success: true,
          message: 'Login Successfully',
          token,
          user: loadUser
        });
      }
      else {
        return res.status(StatusCodes.UNAUTHORIZED).send({
          status: StatusCodes.UNAUTHORIZED,
          success: true,
          message: 'Login Failed',
        });
      }
    } catch (error) {
      logger.error('login', getErrorMsg(error));
      let errStatusCode = StatusCodes.INTERNAL_SERVER_ERROR;
      return res.status(errStatusCode).send({
        success: false,
        message: 'Login failed',
      });
    }
  },
});